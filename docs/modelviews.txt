.. _modelviews:

=========
ModelView
=========

.. module:: towel.modelview


We'll start with simple object list and object detail pages, explaining many
provided tools along the way. Next, this guide covers the CRUD part of Towel,
talk about batch processing a bit and end up with explaining a few components
in more detail.

Please note that Towel's ModelView could be considered similar to Django's own
generic views. However, they do not have the same purpose and software design:
Django's generic views use one class per view, and every instance only processes
one request. Towel's ModelView is more similar to Django's admin site in that
one instance is responsible for many URLs and handles many requests. You have
to take care not to modify ModelView itself during request processing, because
doing this cannot be threadsafe.


Preparing your models, views and URLconfs for ModelView
=======================================================

ModelView has a strong way of how Django-based web applications should be
written. The rigid structure is necessary to build a well-integrated toolset
which will bring you a long way towards successful completion of your project.
If you do not like the design decisions made, ModelView offers hooks to
customize the behavior, but that's not covered in this guide.

For this guide, we assume the following model structure and relationships::

    from django.db import models

    class Publisher(models.Model):
        name = models.CharField(max_length=100)
        address = models.TextField()

    class Author(models.Model):
        name = models.CharField(max_length=100)
        date_of_birth = models.DateField(blank=True, null=True)

    class Book(models.Model):
        title = models.CharField(max_length=100)
        topic = models.CharField(max_length=100)
        authors = models.ManyToManyField(Author)
        published_on = models.DateField()
        publisher = models.ForeignKey(Publisher)


ModelView works with an URL structure similar to the following:

* ``/books/``
* ``/books/<pk>/``
* ``/books/add/``
* ``/books/<pk>/edit/``
* ``/books/<pk>/delete/``

The regular expression used to match the detail page (here <pk>) can be customized. If you'd
rather match on the slug, on a combination of several fields (separated by
dashes or slashes, whatever you want) or on something else, you can do this by
modifying ``urlconf_detail_re``. You only have to make sure that ``get_object``
will know what to do with the extracted parameters.

If you want to use the primary key-based URL configuration, you do not need to add
a ``get_absolute_url`` method to your model, because ModelView will add one
itself. It isn't considered good practice to put primary keys on the web for
everyone to see but it might be okay for your use case.



Object lists
============

Towel`s object lists are handled by ``list_view``. By default, all objects are
shown on one page but this can be modified through ``paginate_by``. The following
code puts a paginated list of books at ``/books/``::

    from myapp.models import Book
    from towel.modelview import ModelView

    class BookModelView(ModelView):
        paginate_by = 20

    book_views = BookModelView(Book)

    urlpatterns = patterns('',
        url(r'^books/', include(book_views.urls)),
    )


This can even be written shorter if you do not want to override any ModelView
methods::

    from myapp.models import Book
    from towel.modelview import ModelView

    urlpatterns = patterns('',
        url(r'^books/', ModelView(Book, paginate_by=20).urls),
    )


Object list call-graph
----------------------

The ``list_view`` method does not contain much code, and simply defers to
other methods who do most of the grunt-work. Those methods are shortly explained
here.

.. function:: list_view

   Main entry point for object lists, calls all other methods.


.. function:: get_query_set

   Receives the request as only argument, must return a queryset of all objects
   a user is allowed to see. The default implementation is ``._default_manager.all()``.


.. function:: handle_search_form
.. function:: handle_batch_form

   These methods are discussed later, under :ref:`object-list-searchable` and
   :ref:`batch-processing`.


.. function:: paginate_object_list

   If ``paginate_by``is given paginates the object list using the ``page`` GET
   parameter. Pagination can be switched off by passing ``all=1`` in the GET
   request.


.. function:: render_list

   The rendering of object lists is done inside ``render_list``. This method
   calls ``get_template`` to assemble a list of templates to try, and
   ``get_context`` to build the context for rendering the final template. The
   templates tried are as follows:

   * ``<app_label>/<model_name>_list.html`` (in our case, ``myapp/book_list.html``)
   * ``modelview/object_list.html``

   The additional variables passed into the context are documented in
   :ref:`standard-context`.



.. _object-list-searchable:

Making lists searchable
-----------------------

Pagination is not enough for many use cases, we need more! Luckily, Towel
has a pre-made solution for searching object lists too.

:class:`towel.forms.SearchForm` can be used together with
:class:`towel.managers.SearchManager` to build a low-cost implementation of
full text search and filtering by model attributes.

The method used to implement full text search is a bit stupid and cannot
replace mature full text search solutions such as Apache Solr. It might just
solve 80% of the problems with 20% of the effort though.

Code talks. First, we extend our models definition with a  ``Manager``
subclass with a simple search implementation::

    from django.db import models
    from towel.managers import SearchManager

    class BookManager(SearchManager):
        search_fields = ('title', 'topic', 'authors__name',
            'publisher__name', 'publisher__address')

    class Book(models.Model):
        # [...]

        objects = BookManager()

:class:`~towel.managers.SearchManager` supports queries with multiple clauses;
terms may be grouped using apostrophes, plus and minus signs may be optionally
prepended to the terms to determine whether the given term should be included
or not. Example::

    +Django "Shop software" -Satchmo

Please note that you can search fields from other models too. You should
be careful when traversing many-to-many relations however, because you will
get duplicated results if you do not call ``.distinct()`` on the resulting
queryset.

The method ``def _search(self, query)`` does the heavy lifting when
constructing a queryset. You should not need to override this method. If you
want to customize the results further, f.e. apply a site-wide limit for the
objects a certain logged in user may see, you should override
``def search(self, query)``. The default :class:`~towel.modelview.ModelView`
implementation assumes this method signature, but you may of course modify it
freely if you want to use this manager with other or modified code. The default
implementation of ``def search(self, query)`` simply calls
``def _search(self, query)``.


Next, we have to create a :class:`~towel.forms.SearchForm` subclass::

    from django import forms
    from towel import forms as towel_forms
    from myapp.models import Author, Book, Publisher

    class BookSearchForm(towel_forms.SearchForm):
        publisher = forms.ModelChoiceField(Publisher.objects.all(), required=False)
        authors = forms.ModelMultipleChoiceField(Author.objects.all(), required=False)
        published_on__lte = forms.DateField(required=False)
        published_on__gte = forms.DateField(required=False)

        formfield_callback = towel_forms.stripped_formfield_callback


You have to add ``required=False`` to every field if you do not want validation
errors on the first visit to the form (which would not make a lot of sense, but
isn't actively harmful).

As long as you only use search form fields whose names correspond to the keywords
used in Django's ``.filter()`` calls or ``Q()`` objects you do not have to do
anything else.

The ``formfield_callback`` simply substitutes a few fields with whitespace-stripping
equivalents, and adds CSS classes to ``DateInput`` and ``DateTimeInput`` so that
they can be easily augmented by javascript code.

To activate this search form, all you have to do is add an additional parameter
when you instantiate the ModelView subclass::

    from myapp.forms import BookSearchForm
    from myapp.models import Book
    from towel.modelview import ModelView

    urlpatterns = patterns('',
        url(r'^books/', ModelView(Book,
            search_form=BookSearchForm,
            paginate_by=20,
            ).urls),
    )


Searches are automatically remembered using Django's session framework; when
the user visits the object list page for the next time, he'll see the filtered
list, not the standard list. This is very convenient for web applications,
especially if users want to do complex searches.



Object detail pages
===================


.. _standard-context:

Standard context variables
==========================


Permissions
===========


Adding and updating objects
===========================


Object deletion
===============


.. _batch-processing:

Batch processing
================
